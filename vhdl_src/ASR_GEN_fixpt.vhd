-- -------------------------------------------------------------
-- 
-- File Name: C:\Users\Asurans\Downloads\fac\tese\window hdl coder\codegen\ASR_GEN\hdlsrc\ASR_GEN_fixpt.vhd
-- Created: 2024-02-12 22:22:48
-- 
-- Generated by MATLAB 9.10, MATLAB Coder 5.2 and HDL Coder 3.18
-- 
-- 
-- 
-- -------------------------------------------------------------
-- Rate and Clocking Details
-- -------------------------------------------------------------
-- Design base rate: 1
-- 
-- 
-- Clock Enable  Sample Time
-- -------------------------------------------------------------
-- ce_out        1
-- -------------------------------------------------------------
-- 
-- 
-- Output Signal                 Clock Enable  Sample Time
-- -------------------------------------------------------------
-- ASR_OUT                       ce_out        1
-- -------------------------------------------------------------
-- 
-- -------------------------------------------------------------


-- -------------------------------------------------------------
-- 
-- Module: ASR_GEN_fixpt
-- Source Path: ASR_GEN_fixpt
-- Hierarchy Level: 0
-- 
-- -------------------------------------------------------------
LIBRARY IEEE;
USE IEEE.std_logic_1164.ALL;
USE IEEE.numeric_std.ALL;

ENTITY ASR_GEN_fixpt IS
  PORT( CLK                               :   IN    std_logic;
        rst                               :   IN    std_logic;
        ce                                :   IN    std_logic;
        ATTACK_CC                         :   IN    unsigned(6 DOWNTO 0);  -- ufix7
        RELEASE_CC                        :   IN    unsigned(6 DOWNTO 0);  -- ufix7
        MAX_ATTACK_MS                     :   IN    unsigned(9 DOWNTO 0);  -- ufix10
        MAX_RELEASE_MS                    :   IN    unsigned(9 DOWNTO 0);  -- ufix10
        CLK_FREQ                          :   IN    unsigned(26 DOWNTO 0);  -- ufix27
        NOTE_ON                           :   IN    std_logic;  -- ufix1
        ASR_IN                            :   IN    signed(15 DOWNTO 0);  -- sfix16
        ce_out                            :   OUT   std_logic;
        ASR_OUT                           :   OUT   signed(15 DOWNTO 0)  -- sfix16
        );
END ASR_GEN_fixpt;


ARCHITECTURE rtl OF ASR_GEN_fixpt IS

  -- Constants
  CONSTANT C_divbyzero_p                  : unsigned(50 DOWNTO 0) := 
    unsigned'("111111111111111111111111111111111111111111111111111");  -- ufix51
  CONSTANT C_divbyzero_p_2                : unsigned(50 DOWNTO 0) := 
    unsigned'("111111111111111111111111111111111111111111111111111");  -- ufix51

  -- Signals
  SIGNAL enb                              : std_logic;
  SIGNAL tmp                              : std_logic;
  SIGNAL state                            : unsigned(1 DOWNTO 0);  -- ufix2
  SIGNAL tmp_1                            : std_logic;
  SIGNAL state_1                          : unsigned(1 DOWNTO 0);  -- ufix2
  SIGNAL state_2                          : unsigned(1 DOWNTO 0);  -- ufix2
  SIGNAL state_3                          : unsigned(1 DOWNTO 0);  -- ufix2
  SIGNAL tmp_2                            : std_logic;
  SIGNAL state_4                          : unsigned(1 DOWNTO 0);  -- ufix2
  SIGNAL tmp_3                            : std_logic;
  SIGNAL attack_ptr                       : unsigned(26 DOWNTO 0);  -- ufix27
  SIGNAL attack_clks                      : unsigned(26 DOWNTO 0);  -- ufix27
  SIGNAL p35attack_clks_mul_temp          : unsigned(36 DOWNTO 0);  -- ufix37
  SIGNAL p35attack_clks_mul_temp_1        : unsigned(52 DOWNTO 0);  -- ufix53_En25
  SIGNAL p35attack_clks_mul_temp_2        : unsigned(59 DOWNTO 0);  -- ufix60_En25
  SIGNAL p35attack_clks_cast              : unsigned(66 DOWNTO 0);  -- ufix67_En32
  SIGNAL p35attack_clks_cast_1            : unsigned(66 DOWNTO 0);  -- ufix67_En32
  SIGNAL p35attack_clks_cast_2            : unsigned(34 DOWNTO 0);  -- ufix35
  SIGNAL state_5                          : unsigned(1 DOWNTO 0);  -- ufix2
  SIGNAL state_6                          : unsigned(1 DOWNTO 0);  -- ufix2
  SIGNAL state_7                          : unsigned(1 DOWNTO 0);  -- ufix2
  SIGNAL state_8                          : unsigned(1 DOWNTO 0);  -- ufix2
  SIGNAL state_9                          : unsigned(1 DOWNTO 0);  -- ufix2
  SIGNAL state_10                         : unsigned(1 DOWNTO 0);  -- ufix2
  SIGNAL state_11                         : unsigned(1 DOWNTO 0);  -- ufix2
  SIGNAL tmp_4                            : std_logic;
  SIGNAL release_clks                     : unsigned(26 DOWNTO 0);  -- ufix27
  SIGNAL p23release_clks_mul_temp         : unsigned(36 DOWNTO 0);  -- ufix37
  SIGNAL p23release_clks_mul_temp_1       : unsigned(52 DOWNTO 0);  -- ufix53_En25
  SIGNAL p23release_clks_mul_temp_2       : unsigned(59 DOWNTO 0);  -- ufix60_En25
  SIGNAL p23release_clks_cast             : unsigned(66 DOWNTO 0);  -- ufix67_En32
  SIGNAL p23release_clks_cast_1           : unsigned(66 DOWNTO 0);  -- ufix67_En32
  SIGNAL p23release_clks_cast_2           : unsigned(34 DOWNTO 0);  -- ufix35
  SIGNAL release_ptr                      : unsigned(26 DOWNTO 0);  -- ufix27
  SIGNAL release_ptr_1                    : unsigned(26 DOWNTO 0);  -- ufix27
  SIGNAL tmp_5                            : std_logic;
  SIGNAL release_ptr_2                    : unsigned(26 DOWNTO 0);  -- ufix27
  SIGNAL release_ptr_3                    : unsigned(26 DOWNTO 0);  -- ufix27
  SIGNAL release_ptr_4                    : unsigned(26 DOWNTO 0);  -- ufix27
  SIGNAL release_ptr_5                    : unsigned(26 DOWNTO 0);  -- ufix27
  SIGNAL release_ptr_6                    : unsigned(26 DOWNTO 0);  -- ufix27
  SIGNAL release_ptr_7                    : unsigned(26 DOWNTO 0);  -- ufix27
  SIGNAL state_12                         : unsigned(1 DOWNTO 0);  -- ufix2
  SIGNAL release_ptr_8                    : unsigned(26 DOWNTO 0);  -- ufix27
  SIGNAL tmp_6                            : unsigned(26 DOWNTO 0);  -- ufix27
  SIGNAL tmp_7                            : std_logic;
  SIGNAL tmp_8                            : unsigned(26 DOWNTO 0);  -- ufix27
  SIGNAL tmp_9                            : signed(31 DOWNTO 0);  -- int32
  SIGNAL release_ptr_10                   : unsigned(26 DOWNTO 0);  -- ufix27
  SIGNAL attack_ptr_1                     : unsigned(26 DOWNTO 0);  -- ufix27
  SIGNAL tmp_10                           : unsigned(26 DOWNTO 0);  -- ufix27
  SIGNAL release_ptr_12                   : unsigned(26 DOWNTO 0);  -- ufix27
  SIGNAL tmp_11                           : unsigned(26 DOWNTO 0);  -- ufix27
  SIGNAL tmp_13                           : unsigned(26 DOWNTO 0);  -- ufix27
  SIGNAL tmp_14                           : std_logic;
  SIGNAL state_13                         : unsigned(1 DOWNTO 0);  -- ufix2
  SIGNAL tmp_15                           : unsigned(1 DOWNTO 0);  -- ufix2
  SIGNAL state_15                         : unsigned(1 DOWNTO 0);  -- ufix2
  SIGNAL tmp_16                           : unsigned(26 DOWNTO 0);  -- ufix27
  SIGNAL tmp_17                           : unsigned(26 DOWNTO 0);  -- ufix27
  SIGNAL tmp_19                           : unsigned(26 DOWNTO 0);  -- ufix27
  SIGNAL tmp_20                           : std_logic;
  SIGNAL tmp_21                           : unsigned(1 DOWNTO 0);  -- ufix2
  SIGNAL tmp_22                           : unsigned(1 DOWNTO 0);  -- ufix2
  SIGNAL state_17                         : unsigned(1 DOWNTO 0);  -- ufix2
  SIGNAL tmp_23                           : unsigned(1 DOWNTO 0);  -- ufix2
  SIGNAL tmp_24                           : unsigned(1 DOWNTO 0);  -- ufix2
  SIGNAL tmp_26                           : unsigned(1 DOWNTO 0);  -- ufix2
  SIGNAL tmp_28                           : signed(15 DOWNTO 0);  -- sfix16
  SIGNAL tmp_30                           : signed(15 DOWNTO 0);  -- sfix16
  SIGNAL tmp_32                           : signed(15 DOWNTO 0);  -- sfix16

BEGIN
  
  tmp <= '1' WHEN NOTE_ON = '1' ELSE
      '0';

  -- HDL code generation from MATLAB function: ASR_GEN_fixpt_trueregionp49
  state <= to_unsigned(16#1#, 2);

  
  tmp_1 <= '1' WHEN NOTE_ON = '0' ELSE
      '0';

  -- HDL code generation from MATLAB function: ASR_GEN_fixpt_trueregionp17
  state_1 <= to_unsigned(16#3#, 2);

  state_2 <= to_unsigned(16#0#, 2);

  state_3 <= to_unsigned(16#0#, 2);

  
  tmp_2 <= '1' WHEN NOTE_ON = '1' ELSE
      '0';

  -- HDL code generation from MATLAB function: ASR_GEN_fixpt_falseregionp25
  state_4 <= to_unsigned(16#3#, 2);

  
  tmp_3 <= '1' WHEN NOTE_ON = '1' ELSE
      '0';

  -- HDL code generation from MATLAB function: ASR_GEN_fixpt_trueregionp46
  attack_ptr <= to_unsigned(16#0000000#, 27);

  enb <= ce;

  -- 'ASR_GEN_fixpt:104' a1 = fi( a, 'RoundMode', 'fix' );
  -- 
  -- 'ASR_GEN_fixpt:103' coder.inline( 'always' );
  -- 
  -- 'ASR_GEN_fixpt:51' ASR_OUT = fi(floor(fi_div(attack_ptr, attack_clks) *ASR_IN), 1, 16, 0, fm);
  -- 
  -- 'ASR_GEN_fixpt:50' else
  -- 
  -- 'ASR_GEN_fixpt:48' if attack_clks == fi(0, 0, 1, 0, fm)
  -- 
  -- 'ASR_GEN_fixpt:42' state(:) = 2;
  -- 
  -- 'ASR_GEN_fixpt:41' if attack_ptr >= attack_clks
  -- 
  -- 'ASR_GEN_fixpt:46' release_ptr(:) = attack_ptr;
  -- 
  -- 'ASR_GEN_fixpt:45' state(:) = 3;
  -- 
  -- 'ASR_GEN_fixpt:44' else
  -- 
  -- 'ASR_GEN_fixpt:40' if NOTE_ON == fi(1, 0, 1, 0, fm)
  -- 
  -- Attack state
  -- 
  -- 'ASR_GEN_fixpt:39' case fi(1, 0, 1, 0, fm)
  -- 
  -- 'ASR_GEN_fixpt:36' state(:) = 1;
  -- 
  -- 'ASR_GEN_fixpt:35' attack_ptr(:) = 0;
  -- 
  -- 'ASR_GEN_fixpt:34' if NOTE_ON == fi(1, 0, 1, 0, fm)
  -- 
  -- 'ASR_GEN_fixpt:33' ASR_OUT = fi(0, 1, 16, 0, fm);
  -- 
  -- Idle state
  -- 
  -- 'ASR_GEN_fixpt:32' case fi(0, 0, 1, 0, fm)
  -- 
  -- F2F: End block
  -- 
  -- 'ASR_GEN_fixpt:78' state(:) = 0;
  -- 
  -- 'ASR_GEN_fixpt:77' ASR_OUT = fi(0, 1, 16, 0, fm);
  -- 
  -- F2F: Start block
  -- 
  -- F2F: No information found for converting the following block of code
  -- 
  -- 'ASR_GEN_fixpt:74' otherwise
  -- 
  -- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
  -- 
  --                                                                          %
  -- 
  --          Generated by MATLAB 9.10 and Fixed-Point Designer 7.2           %
  -- 
  --                                                                          %
  -- 
  -- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
  -- 
  -- CC_attack and CC_release are MIDI CC parameters which can vary between
  -- 
  -- 0-127 where 0=0% and 127=50%
  -- 
  -- 0 => Idle; 1 => Attack; 2 => Sustain; 3 => Release
  -- 
  -- 'ASR_GEN_fixpt:11' fm = get_fimath();
  -- 
  -- 'ASR_GEN_fixpt:14' if isempty(state)
  -- 
  -- 'ASR_GEN_fixpt:19' if isempty(attack_ptr)
  -- 
  -- 'ASR_GEN_fixpt:24' if isempty(release_ptr)
  -- 
  -- 'ASR_GEN_fixpt:28' attack_clks  = fi(floor(fi_div_by_shift(CLK_FREQ*MAX_ATTACK_MS*fi(1/1000, 0, 16, 25, fm)  *ATTACK_CC, 
  -- 7)), 0, 27, 0, fm)
  -- 
  -- 'ASR_GEN_fixpt:117' coder.inline( 'always' );
  -- 
  -- 'ASR_GEN_fixpt:118' if isfi( a )
  -- 
  -- 'ASR_GEN_fixpt:119' nt = numerictype( a );
  -- 
  -- 'ASR_GEN_fixpt:120' fm = fimath( a );
  -- 
  -- 'ASR_GEN_fixpt:121' nt_bs = numerictype( nt.Signed, nt.WordLength + shift_len, nt.FractionLength + shift_len );
  -- 
  -- 'ASR_GEN_fixpt:122' y = bitsra( fi( a, nt_bs, fm ), shift_len );
  -- 
  -- 'ASR_GEN_fixpt:66' release_ptr(:) = release_ptr - fi(1, 0, 1, 0, fm);
  -- 
  -- 'ASR_GEN_fixpt:65' else
  -- 
  -- 'ASR_GEN_fixpt:63' if NOTE_ON == fi(1, 0, 1, 0, fm) || release_ptr == fi(0, 0, 1, 0, fm)
  -- 
  -- Release state
  -- 
  -- 'ASR_GEN_fixpt:62' case fi(3, 0, 2, 0, fm)
  -- 
  -- 'ASR_GEN_fixpt:59' release_ptr(:) = release_clks;
  -- 
  -- 'ASR_GEN_fixpt:58' state(:) = 3;
  -- 
  -- 'ASR_GEN_fixpt:57' if NOTE_ON == fi(0, 0, 1, 0, fm)
  p35attack_clks_mul_temp <= CLK_FREQ * MAX_ATTACK_MS;
  p35attack_clks_mul_temp_1 <= p35attack_clks_mul_temp * to_unsigned(16#8312#, 16);
  p35attack_clks_mul_temp_2 <= p35attack_clks_mul_temp_1 * ATTACK_CC;
  p35attack_clks_cast <= p35attack_clks_mul_temp_2 & '0' & '0' & '0' & '0' & '0' & '0' & '0';
  p35attack_clks_cast_1 <= SHIFT_RIGHT(p35attack_clks_cast, 7);
  p35attack_clks_cast_2 <= p35attack_clks_cast_1(66 DOWNTO 32);
  attack_clks <= p35attack_clks_cast_2(26 DOWNTO 0);

  -- HDL code generation from MATLAB function: ASR_GEN_fixpt_trueregionp32
  state_5 <= to_unsigned(16#2#, 2);

  state_6 <= to_unsigned(16#0#, 2);

  state_7 <= to_unsigned(16#0#, 2);

  state_8 <= to_unsigned(16#0#, 2);

  state_9 <= to_unsigned(16#0#, 2);

  state_10 <= to_unsigned(16#0#, 2);

  state_11 <= to_unsigned(16#0#, 2);

  
  tmp_4 <= '1' WHEN NOTE_ON = '0' ELSE
      '0';

  -- 'ASR_GEN_fixpt:29' release_clks = fi(floor(fi_div_by_shift(CLK_FREQ*MAX_RELEASE_MS*fi(1/1000, 0, 16, 25, fm) *RELEASE_CC, 
  -- 7)), 0, 27, 0, fm)
  -- 
  -- 'ASR_GEN_fixpt:117' coder.inline( 'always' );
  -- 
  -- 'ASR_GEN_fixpt:118' if isfi( a )
  -- 
  -- 'ASR_GEN_fixpt:119' nt = numerictype( a );
  -- 
  -- 'ASR_GEN_fixpt:120' fm = fimath( a );
  -- 
  -- 'ASR_GEN_fixpt:121' nt_bs = numerictype( nt.Signed, nt.WordLength + shift_len, nt.FractionLength + shift_len );
  -- 
  -- 'ASR_GEN_fixpt:122' y = bitsra( fi( a, nt_bs, fm ), shift_len );
  -- 
  -- HDL code generation from MATLAB function: ASR_GEN_fixpt_trueregionp20
  p23release_clks_mul_temp <= CLK_FREQ * MAX_RELEASE_MS;
  p23release_clks_mul_temp_1 <= p23release_clks_mul_temp * to_unsigned(16#8312#, 16);
  p23release_clks_mul_temp_2 <= p23release_clks_mul_temp_1 * RELEASE_CC;
  p23release_clks_cast <= p23release_clks_mul_temp_2 & '0' & '0' & '0' & '0' & '0' & '0' & '0';
  p23release_clks_cast_1 <= SHIFT_RIGHT(p23release_clks_cast, 7);
  p23release_clks_cast_2 <= p23release_clks_cast_1(66 DOWNTO 32);
  release_clks <= p23release_clks_cast_2(26 DOWNTO 0);

  release_ptr <= to_unsigned(16#0000000#, 27);

  release_ptr_1 <= to_unsigned(16#0000000#, 27);

  
  tmp_5 <= '1' WHEN NOTE_ON = '1' ELSE
      '0';

  release_ptr_2 <= to_unsigned(16#0000000#, 27);

  release_ptr_3 <= to_unsigned(16#0000000#, 27);

  release_ptr_4 <= to_unsigned(16#0000000#, 27);

  release_ptr_5 <= to_unsigned(16#0000000#, 27);

  release_ptr_6 <= to_unsigned(16#0000000#, 27);

  release_ptr_7 <= to_unsigned(16#0000000#, 27);

  -- HDL code generation from MATLAB function: ASR_GEN_fixpt_trueregionp39
  state_12 <= to_unsigned(16#0#, 2);

  -- 'ASR_GEN_fixpt:69' ASR_OUT = fi(0, 1, 16, 0, fm);
  -- 
  -- 'ASR_GEN_fixpt:109' c = fi( c1, numerictype( c1 ), fimath( a ) );
  -- 
  -- 'ASR_GEN_fixpt:108' c1 = divide( nType, a1, b1 );
  -- 
  -- 'ASR_GEN_fixpt:107' if isfi( a ) && isfi( b ) && isscalar( b )
  -- 
  -- 'ASR_GEN_fixpt:106' nType = divideType( a1, b1 );
  -- 
  -- 'ASR_GEN_fixpt:105' b1 = fi( b, 'RoundMode', 'fix' );
  -- 
  -- 'ASR_GEN_fixpt:104' a1 = fi( a, 'RoundMode', 'fix' );
  -- 
  -- 'ASR_GEN_fixpt:103' coder.inline( 'always' );
  -- 
  -- 'ASR_GEN_fixpt:71' ASR_OUT = fi(floor(fi_div(release_ptr, release_clks) *ASR_IN), 1, 16, 0, fm);
  -- 
  -- 'ASR_GEN_fixpt:70' else
  -- 
  -- 'ASR_GEN_fixpt:68' if release_clks == fi(0, 0, 1, 0, fm)
  -- 
  -- 'ASR_GEN_fixpt:64' state(:) = 0;
  -- 
  -- HDL code generation from MATLAB function: ASR_GEN_fixpt_falseregionp42
  tmp_6 <= release_ptr_8 - to_unsigned(16#0000001#, 27);

  
  tmp_7 <= '1' WHEN (NOTE_ON = '1') OR (release_ptr_8 = to_unsigned(16#0000000#, 27)) ELSE
      '0';

  
  tmp_8 <= tmp_6 WHEN tmp_7 = '0' ELSE
      release_ptr_8;

  p9_output : PROCESS (release_ptr_4, release_ptr_5, release_ptr_6, release_ptr_7, tmp_8, tmp_9)
    VARIABLE release_ptr9 : unsigned(26 DOWNTO 0);
  BEGIN
    CASE tmp_9 IS
      WHEN "00000000000000000000000000000000" =>
        release_ptr9 := release_ptr_5;
      WHEN "00000000000000000000000000000001" =>
        release_ptr9 := release_ptr_6;
      WHEN "00000000000000000000000000000010" =>
        release_ptr9 := release_ptr_7;
      WHEN "00000000000000000000000000000011" =>
        release_ptr9 := tmp_8;
      WHEN OTHERS => 
        release_ptr9 := release_ptr_4;
    END CASE;
    release_ptr_10 <= release_ptr9;
  END PROCESS p9_output;


  
  tmp_10 <= attack_ptr_1 WHEN tmp_5 = '0' ELSE
      release_ptr_8;

  p11_output : PROCESS (release_ptr, release_ptr_1, release_ptr_2, release_ptr_3, tmp_10, tmp_9)
    VARIABLE release_ptr11 : unsigned(26 DOWNTO 0);
  BEGIN
    CASE tmp_9 IS
      WHEN "00000000000000000000000000000000" =>
        release_ptr11 := release_ptr_1;
      WHEN "00000000000000000000000000000001" =>
        release_ptr11 := tmp_10;
      WHEN "00000000000000000000000000000010" =>
        release_ptr11 := release_ptr_2;
      WHEN "00000000000000000000000000000011" =>
        release_ptr11 := release_ptr_3;
      WHEN OTHERS => 
        release_ptr11 := release_ptr;
    END CASE;
    release_ptr_12 <= release_ptr11;
  END PROCESS p11_output;


  
  tmp_11 <= release_ptr_8 WHEN tmp_4 = '0' ELSE
      release_clks;

  p3_output : PROCESS (release_ptr_10, release_ptr_12, release_ptr_8, tmp_11, tmp_9)
    VARIABLE tmp12 : unsigned(26 DOWNTO 0);
  BEGIN
    CASE tmp_9 IS
      WHEN "00000000000000000000000000000000" =>
        tmp12 := release_ptr_8;
      WHEN "00000000000000000000000000000001" =>
        tmp12 := release_ptr_12;
      WHEN "00000000000000000000000000000010" =>
        tmp12 := tmp_11;
      WHEN "00000000000000000000000000000011" =>
        tmp12 := release_ptr_10;
      WHEN OTHERS => 
        tmp12 := release_ptr_8;
    END CASE;
    tmp_13 <= tmp12;
  END PROCESS p3_output;


  release_ptr_reg_process : PROCESS (CLK, rst)
  BEGIN
    IF rst = '1' THEN
      release_ptr_8 <= to_unsigned(16#0000000#, 27);
    ELSIF CLK'EVENT AND CLK = '1' THEN
      IF enb = '1' THEN
        release_ptr_8 <= tmp_13;
      END IF;
    END IF;
  END PROCESS release_ptr_reg_process;


  
  tmp_14 <= '1' WHEN (NOTE_ON = '1') OR (release_ptr_8 = to_unsigned(16#0000000#, 27)) ELSE
      '0';

  
  tmp_15 <= state_13 WHEN tmp_14 = '0' ELSE
      state_12;

  p10_output : PROCESS (state_10, state_11, state_8, state_9, tmp_15, tmp_9)
    VARIABLE state14 : unsigned(1 DOWNTO 0);
  BEGIN
    CASE tmp_9 IS
      WHEN "00000000000000000000000000000000" =>
        state14 := state_9;
      WHEN "00000000000000000000000000000001" =>
        state14 := state_10;
      WHEN "00000000000000000000000000000010" =>
        state14 := state_11;
      WHEN "00000000000000000000000000000011" =>
        state14 := tmp_15;
      WHEN OTHERS => 
        state14 := state_8;
    END CASE;
    state_15 <= state14;
  END PROCESS p10_output;


  -- 'ASR_GEN_fixpt:56' ASR_OUT = fi(ASR_IN, 1, 16, 0, fm);
  -- 
  -- Sustain state
  -- 
  -- 'ASR_GEN_fixpt:55' case fi(2, 0, 2, 0, fm)
  tmp_16 <= attack_ptr_1 + to_unsigned(16#0000001#, 27);

  
  tmp_17 <= attack_ptr_1 WHEN tmp_3 = '0' ELSE
      attack_ptr;

  p5_output : PROCESS (attack_ptr_1, tmp_16, tmp_17, tmp_9)
    VARIABLE tmp18 : unsigned(26 DOWNTO 0);
  BEGIN
    CASE tmp_9 IS
      WHEN "00000000000000000000000000000000" =>
        tmp18 := tmp_17;
      WHEN "00000000000000000000000000000001" =>
        tmp18 := tmp_16;
      WHEN "00000000000000000000000000000010" =>
        tmp18 := attack_ptr_1;
      WHEN "00000000000000000000000000000011" =>
        tmp18 := attack_ptr_1;
      WHEN OTHERS => 
        tmp18 := attack_ptr_1;
    END CASE;
    tmp_19 <= tmp18;
  END PROCESS p5_output;


  -- HDL code generation from MATLAB function: ASR_GEN_fixpt_falseregionp29
  -- 
  -- 'ASR_GEN_fixpt:53' attack_ptr(:) = attack_ptr + fi(1, 0, 1, 0, fm);
  -- 
  -- 'ASR_GEN_fixpt:49' ASR_OUT = fi(0, 1, 16, 0, fm);
  -- 
  -- 'ASR_GEN_fixpt:109' c = fi( c1, numerictype( c1 ), fimath( a ) );
  -- 
  -- 'ASR_GEN_fixpt:108' c1 = divide( nType, a1, b1 );
  -- 
  -- 'ASR_GEN_fixpt:107' if isfi( a ) && isfi( b ) && isscalar( b )
  -- 
  -- 'ASR_GEN_fixpt:106' nType = divideType( a1, b1 );
  -- 
  -- 'ASR_GEN_fixpt:105' b1 = fi( b, 'RoundMode', 'fix' );
  attack_ptr_reg_process : PROCESS (CLK, rst)
  BEGIN
    IF rst = '1' THEN
      attack_ptr_1 <= to_unsigned(16#0000000#, 27);
    ELSIF CLK'EVENT AND CLK = '1' THEN
      IF enb = '1' THEN
        attack_ptr_1 <= tmp_19;
      END IF;
    END IF;
  END PROCESS attack_ptr_reg_process;


  
  tmp_20 <= '1' WHEN attack_ptr_1 >= attack_clks ELSE
      '0';

  -- HDL code generation from MATLAB function: ASR_GEN_fixpt_trueregionp25
  
  tmp_21 <= state_13 WHEN tmp_20 = '0' ELSE
      state_5;

  
  tmp_22 <= state_4 WHEN tmp_2 = '0' ELSE
      tmp_21;

  p12_output : PROCESS (state_2, state_3, state_6, state_7, tmp_22, tmp_9)
    VARIABLE state16 : unsigned(1 DOWNTO 0);
  BEGIN
    CASE tmp_9 IS
      WHEN "00000000000000000000000000000000" =>
        state16 := state_3;
      WHEN "00000000000000000000000000000001" =>
        state16 := tmp_22;
      WHEN "00000000000000000000000000000010" =>
        state16 := state_6;
      WHEN "00000000000000000000000000000011" =>
        state16 := state_7;
      WHEN OTHERS => 
        state16 := state_2;
    END CASE;
    state_17 <= state16;
  END PROCESS p12_output;


  
  tmp_23 <= state_13 WHEN tmp_1 = '0' ELSE
      state_1;

  
  tmp_24 <= state_13 WHEN tmp = '0' ELSE
      state;

  p8_output : PROCESS (state_15, state_17, tmp_23, tmp_24, tmp_9)
    VARIABLE tmp25 : unsigned(1 DOWNTO 0);
  BEGIN
    CASE tmp_9 IS
      WHEN "00000000000000000000000000000000" =>
        tmp25 := tmp_24;
      WHEN "00000000000000000000000000000001" =>
        tmp25 := state_17;
      WHEN "00000000000000000000000000000010" =>
        tmp25 := tmp_23;
      WHEN "00000000000000000000000000000011" =>
        tmp25 := state_15;
      WHEN OTHERS => 
        tmp25 := to_unsigned(16#0#, 2);
    END CASE;
    tmp_26 <= tmp25;
  END PROCESS p8_output;


  state_reg_process : PROCESS (CLK, rst)
  BEGIN
    IF rst = '1' THEN
      state_13 <= to_unsigned(16#0#, 2);
    ELSIF CLK'EVENT AND CLK = '1' THEN
      IF enb = '1' THEN
        state_13 <= tmp_26;
      END IF;
    END IF;
  END PROCESS state_reg_process;


  -- 'ASR_GEN_fixpt:31' switch state
  tmp_9 <= signed(resize(state_13, 32));

  p13_output : PROCESS (ASR_IN, attack_clks, attack_ptr_1, tmp_9)
    VARIABLE tmp27 : unsigned(53 DOWNTO 0);
    VARIABLE tmp_0 : signed(15 DOWNTO 0);
    VARIABLE tmp_12 : signed(15 DOWNTO 0);
    VARIABLE div_temp : unsigned(50 DOWNTO 0);
    VARIABLE cast : unsigned(50 DOWNTO 0);
    VARIABLE cast_0 : signed(54 DOWNTO 0);
    VARIABLE mul_temp : signed(70 DOWNTO 0);
    VARIABLE cast_1 : signed(69 DOWNTO 0);
    VARIABLE cast_2 : signed(45 DOWNTO 0);
  BEGIN
    tmp_0 := to_signed(16#0000#, 16);
    tmp27 := to_unsigned(0, 54);
    div_temp := to_unsigned(0, 51);
    mul_temp := to_signed(0, 71);
    cast := to_unsigned(0, 51);
    cast_0 := to_signed(0, 55);
    cast_1 := to_signed(0, 70);
    cast_2 := to_signed(0, 46);
    CASE tmp_9 IS
      WHEN "00000000000000000000000000000000" =>
        tmp_12 := to_signed(16#0000#, 16);
      WHEN "00000000000000000000000000000001" =>
        IF attack_clks = to_unsigned(16#0000000#, 27) THEN 
          tmp_0 := to_signed(16#0000#, 16);
        ELSE 
          IF attack_clks = to_unsigned(16#0000000#, 27) THEN 
            tmp27 := unsigned'("111111111111111111111111111111111111111111111111111111");
          ELSE 
            cast := attack_ptr_1 & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0';
            IF attack_clks = 0 THEN 
              div_temp := C_divbyzero_p;
            ELSE 
              div_temp := cast / attack_clks;
            END IF;
            tmp27 := resize(div_temp, 54);
          END IF;
          cast_0 := signed(resize(tmp27, 55));
          mul_temp := cast_0 * ASR_IN;
          cast_1 := mul_temp(69 DOWNTO 0);
          cast_2 := cast_1(69 DOWNTO 24);
          tmp_0 := cast_2(15 DOWNTO 0);
        END IF;
        tmp_12 := tmp_0;
      WHEN "00000000000000000000000000000010" =>
        tmp_12 := to_signed(16#0000#, 16);
      WHEN "00000000000000000000000000000011" =>
        tmp_12 := to_signed(16#0000#, 16);
      WHEN OTHERS => 
        tmp_12 := to_signed(16#0000#, 16);
    END CASE;
    tmp_28 <= tmp_12;
  END PROCESS p13_output;


  -- HDL code generation from MATLAB function: ASR_GEN_fixpt
  p14_output : PROCESS (ASR_IN, release_clks, tmp_8, tmp_9)
    VARIABLE tmp29 : unsigned(53 DOWNTO 0);
    VARIABLE tmp_01 : signed(15 DOWNTO 0);
    VARIABLE tmp_18 : signed(15 DOWNTO 0);
    VARIABLE div_temp1 : unsigned(50 DOWNTO 0);
    VARIABLE cast1 : unsigned(50 DOWNTO 0);
    VARIABLE cast_01 : signed(54 DOWNTO 0);
    VARIABLE mul_temp1 : signed(70 DOWNTO 0);
    VARIABLE cast_11 : signed(69 DOWNTO 0);
    VARIABLE cast_21 : signed(45 DOWNTO 0);
  BEGIN
    tmp_01 := to_signed(16#0000#, 16);
    tmp29 := to_unsigned(0, 54);
    div_temp1 := to_unsigned(0, 51);
    mul_temp1 := to_signed(0, 71);
    cast1 := to_unsigned(0, 51);
    cast_01 := to_signed(0, 55);
    cast_11 := to_signed(0, 70);
    cast_21 := to_signed(0, 46);
    CASE tmp_9 IS
      WHEN "00000000000000000000000000000000" =>
        tmp_18 := to_signed(16#0000#, 16);
      WHEN "00000000000000000000000000000001" =>
        tmp_18 := to_signed(16#0000#, 16);
      WHEN "00000000000000000000000000000010" =>
        tmp_18 := to_signed(16#0000#, 16);
      WHEN "00000000000000000000000000000011" =>
        IF release_clks = to_unsigned(16#0000000#, 27) THEN 
          tmp_01 := to_signed(16#0000#, 16);
        ELSE 
          IF release_clks = to_unsigned(16#0000000#, 27) THEN 
            tmp29 := unsigned'("111111111111111111111111111111111111111111111111111111");
          ELSE 
            cast1 := tmp_8 & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0';
            IF release_clks = 0 THEN 
              div_temp1 := C_divbyzero_p_2;
            ELSE 
              div_temp1 := cast1 / release_clks;
            END IF;
            tmp29 := resize(div_temp1, 54);
          END IF;
          cast_01 := signed(resize(tmp29, 55));
          mul_temp1 := cast_01 * ASR_IN;
          cast_11 := mul_temp1(69 DOWNTO 0);
          cast_21 := cast_11(69 DOWNTO 24);
          tmp_01 := cast_21(15 DOWNTO 0);
        END IF;
        tmp_18 := tmp_01;
      WHEN OTHERS => 
        tmp_18 := to_signed(16#0000#, 16);
    END CASE;
    tmp_30 <= tmp_18;
  END PROCESS p14_output;


  p6_output : PROCESS (ASR_IN, tmp_28, tmp_30, tmp_9)
    VARIABLE tmp31 : signed(15 DOWNTO 0);
  BEGIN
    CASE tmp_9 IS
      WHEN "00000000000000000000000000000000" =>
        tmp31 := to_signed(16#0000#, 16);
      WHEN "00000000000000000000000000000001" =>
        tmp31 := tmp_28;
      WHEN "00000000000000000000000000000010" =>
        tmp31 := ASR_IN;
      WHEN "00000000000000000000000000000011" =>
        tmp31 := tmp_30;
      WHEN OTHERS => 
        tmp31 := to_signed(16#0000#, 16);
    END CASE;
    tmp_32 <= tmp31;
  END PROCESS p6_output;


  ce_out <= ce;

  ASR_OUT <= tmp_32;

END rtl;

