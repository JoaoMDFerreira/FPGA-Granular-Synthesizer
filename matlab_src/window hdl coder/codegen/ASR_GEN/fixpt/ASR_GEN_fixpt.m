%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%                                                                          %
%          Generated by MATLAB 9.10 and Fixed-Point Designer 7.2           %
%                                                                          %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%#codegen
%CC_attack and CC_release are MIDI CC parameters which can vary between
%0-127 where 0=0% and 127=50%
function ASR_OUT = ASR_GEN_fixpt(ATTACK_CC, RELEASE_CC,MAX_ATTACK_MS,MAX_RELEASE_MS,CLK_FREQ,NOTE_ON,ASR_IN)
    % 0 => Idle; 1 => Attack; 2 => Sustain; 3 => Release
    fm = get_fimath();

    persistent state;
    if isempty(state)
        state = fi(0, 0, 2, 0, fm);
    end
    
    persistent attack_ptr;
    if isempty(attack_ptr)
        attack_ptr = fi(0, 0, 27, 0, fm);
    end
    
    persistent release_ptr;
    if isempty(release_ptr)
        release_ptr = fi(0, 0, 27, 0, fm);
    end
    
    attack_clks  = fi(floor(fi_div_by_shift(CLK_FREQ*MAX_ATTACK_MS*fi(1/1000, 0, 16, 25, fm)  *ATTACK_CC, 7)), 0, 27, 0, fm);
    release_clks = fi(floor(fi_div_by_shift(CLK_FREQ*MAX_RELEASE_MS*fi(1/1000, 0, 16, 25, fm) *RELEASE_CC, 7)), 0, 27, 0, fm);
    
    switch state
        case fi(0, 0, 1, 0, fm) %Idle state
            ASR_OUT = fi(0, 1, 16, 0, fm);
            if NOTE_ON == fi(1, 0, 1, 0, fm)
                attack_ptr(:) = 0;
                state(:) = 1;
            end
            
        case fi(1, 0, 1, 0, fm) %Attack state
            if NOTE_ON == fi(1, 0, 1, 0, fm)
                if attack_ptr >= attack_clks
                    state(:) = 2;
                end
            else
                state(:) = 3;
                release_ptr(:) = attack_ptr;
            end
            if attack_clks == fi(0, 0, 1, 0, fm)
                ASR_OUT = fi(0, 1, 16, 0, fm);
            else
                ASR_OUT = fi(floor(fi_div(attack_ptr, attack_clks) *ASR_IN), 1, 16, 0, fm);
            end
            attack_ptr(:) = attack_ptr + fi(1, 0, 1, 0, fm);
            
        case fi(2, 0, 2, 0, fm) %Sustain state
            ASR_OUT = fi(ASR_IN, 1, 16, 0, fm);
            if NOTE_ON == fi(0, 0, 1, 0, fm)
                state(:) = 3;
                release_ptr(:) = release_clks;
            end
            
        case fi(3, 0, 2, 0, fm) %Release state
            if NOTE_ON == fi(1, 0, 1, 0, fm) || release_ptr == fi(0, 0, 1, 0, fm)
                state(:) = 0;
            else
                release_ptr(:) = release_ptr - fi(1, 0, 1, 0, fm);
            end
            if release_clks == fi(0, 0, 1, 0, fm)
                ASR_OUT = fi(0, 1, 16, 0, fm);
            else
                ASR_OUT = fi(floor(fi_div(release_ptr, release_clks) *ASR_IN), 1, 16, 0, fm);
            end
            
        otherwise
            %F2F: No information found for converting the following block of code
            %F2F: Start block
            ASR_OUT = fi(0, 1, 16, 0, fm);
            state(:) = 0;
            %F2F: End block
    end
end



function ntype = divideType(a,b)
    coder.inline( 'always' );
    nt1 = numerictype( a );
    nt2 = numerictype( b );
    maxFL = max( [ min( nt1.WordLength, nt1.FractionLength ), min( nt2.WordLength, nt2.FractionLength ) ] );
    FL = max( maxFL, 24 );
    extraBits = (FL - maxFL);
    WL = nt1.WordLength + nt2.WordLength;
    WL = min( WL, 124 );
    if (WL + extraBits)<64
        ntype = numerictype( nt1.Signed || nt2.Signed, WL + extraBits, FL );
    else
        ntype = numerictype( nt1.Signed || nt2.Signed, WL, FL );
    end
end


function c = fi_div(a,b)
    coder.inline( 'always' );
    a1 = fi( a, 'RoundMode', 'fix' );
    b1 = fi( b, 'RoundMode', 'fix' );
    nType = divideType( a1, b1 );
    if isfi( a ) && isfi( b ) && isscalar( b )
        c1 = divide( nType, a1, b1 );
        c = fi( c1, numerictype( c1 ), fimath( a ) );
    else
        c = fi( a / b, nType );
    end
end


function y = fi_div_by_shift(a,shift_len)
    coder.inline( 'always' );
    if isfi( a )
        nt = numerictype( a );
        fm = fimath( a );
        nt_bs = numerictype( nt.Signed, nt.WordLength + shift_len, nt.FractionLength + shift_len );
        y = bitsra( fi( a, nt_bs, fm ), shift_len );
    else
        y = a / 2 ^ shift_len;
    end
end

function fm = get_fimath()
	fm = fimath('RoundingMethod', 'Floor',...
	     'OverflowAction', 'Wrap',...
	     'ProductMode','FullPrecision',...
	     'MaxProductWordLength', 128,...
	     'SumMode','FullPrecision',...
	     'MaxSumWordLength', 128);
end
